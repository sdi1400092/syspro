Μαζέρας Αντώνιος
Α.Μ. : 1115201400092

1η Εργασία Προγραμματισμού συστήματος


Για να κανει compile η εργασια χρησιμοποιηται η εντολη: make sniffer
Με τη χρηση αυτης της εντολης διαγραφονται υπαρχοντα αρχεια named pipes(fifo*) και *.out αρχεια που δημιουργηθηκαν με προηγουμενες κλησης του sniffer
Για να τρεξει ο sniffer χρησιμοποιηται η εντολη ./sniffer δεν υπαρχει δυνατοτητα για [-p path] παραμετρο αλλα ειναι ενσωματομενη στο κωδικα.

Το αρχείο με τον κωδικα της εργασιας περιεχει τα εξης αρχεια:
    • sniffer.c
στο οποιο περιεχεται ο κορμος του κωδικα της εργασιας μαζι με καποιες βοηθητικες συναρτησεις
    • queue.h
οπου ειναι οι ορισμοι των συναρτησεων που χρειαστηκαν για την υλοποιηση της ουρας
    • queueimplementation.c
οι υλοποιησης των συναρτησεων της ουρας
    • το directory notifyDir
Αυτο το directory ειναι που παρακολουθει η inotifywait
    • makefile
ενα makefile αρχειο για το compile της εργασιας

sniffer.c:
    • main: στη main ξεκιναω με τη δημιουργια του pipe που θα επικοινωνει ο manager με το listener με το αρχικο fork() για τη δημιουργια του listener. Στη συνεχεια γινεται ελεγχος για την τιμη του fork() για να δουμε αν ειμαστε στον manager ή στον listener. Ο listener στην αρχή κλεινει το fd[0] δηλαδη το read end του pipe γιατι δεν θα χρειαστει να διαβασει κατι απο το pipe. Μετά, δημιοουργει ενα πινακα με τα ορισματα που θα τρεξει η inotifywait, αντιγραφει το stdout στο fd[1] δηλαδη το write end του pipe ετσι ωστε οτι θα εκτυπωνε ο listener στην οθονη θα το κανει write στο pipe. Ο manager με τη σειρα του, ξεκιναει με ενα while(1) που θα τρεχει μεχρι αν δωθει εντολη ctrl+C απο το χρηστη. Στη συνεχεια, κανει read απο το pipe και παιρνει το ονομα του αρχειου που ειτε δημιουργηθηκε στο directory που παρακολουθει ο listener(notifyDir) ειτε μετακινηθηκε σε αυτο. Στη συνεχεια αν η ουρα με τους διαθεσιμους worker ειναι αδεια δημιουργει ενα named pipe και κανει fork() για να δημιουργησει ενα worker. Κανει ελεγχο για το αν βρισκεται στο manager ακομα ή στον worker. Αν ειναι στον manager κανει open το named pipe που αντιστοιχει στον worker που μολις δημιουργηθηκε και διαβαζει απο αυτο το pid του worker και το κανει push στην ουρα σε ενα struct μαζι με το ονομα του αρχειου named pipe. Μετα απο αυτο βγαινει απο το if(queue == empty) και κανει pop απο το queue εναν worker διαθεσιμο με τη μορφη του struct και του στελνει σημα SIGCONT για να ξεκινησει παλι την λειτουργια του. Ξαναελεγχει αν βρισκεται στον manager και μεσα σε αυτο το if ξανανοιγει το named pipe και γραφει μεσα σε αυτο το filename του αρχειου που πρεπει να ανοιχθει απο τον worker και να ψαχθει για URLs. Γυρνοντας λιγο πιο πανω στις γραμμες, βρισκεται η συνθηκη if(id2 == 0) που ελεγχει αν βρισκομαστε στο κομματι κωδικα του worker. Μεσα σε αυτη τη συνθηκη ανοιγει ο worker το named pipe του και γραφει σε αυτο το processid του για να το διαβασει ο  manager και να το κανει push στην ουρα του και μολις κλεισει το named pipe κανει signal στον εαυτο του να κανει SIGSTOP και να περιμενει τον manager να του στειλει σημα SIGCONT μετα το pop απο τη λιστα. Αφοτου παρει σημα SIGCONT ανοιγει παλι το named pipe για να διαβασει απο αυτο το ονομα του αρχειου που πρεπει να ανοιχτει. O worker με τη σειρα του καλει τη συναρτηση  geturls() η οποια παιρνει σαν ορισμα ενα string και ανοιγει το αρχειο με ονομα αυτο το string. Με τη σειρα της ψαχνει μεσα σε αυτο το αρχειο για URLs της μορφης http:// και απο αυτα κραταει μονο το location. Τελος, ανοιγει ενα αρχειο *.out οπου * το ονομα του αρχειου με το οποιο καλεστηκε σαν ορισμα και σε αυτο γραφει τα location που βρεθηκαν στο αρχειο μαζι με το ποσες φορες βρεθηκε το καθ’ενα απο αυτα και τελος κανει SIGSTOP στον εαυτο του ο worker μολις τελειωσει με το αρχειο αυτο περιμενοντας τον manager να του στειλει σημα ξανα να συνεχισει. Το κομματι κωδικα του worker που κανει την επεξεργασια του αρχειου βρισκεται μεσα σε ενα while(1) για να τρεχει μεχρι αν δωθει η εντολη ctrl+C απο το χρηστη για να τερματιστει (συμφωνα με την εκφωνηση θα επρεπε μολις δωθει αυτη η εντολη απο το χρηστη να τη πιανει ο manager και να στελνει σημα SIGKILL στους worker για να τερματιζουν αλλα αυτο το κομματι κωδικα δεν καταφερα να το υλοποιησω). 
    • fifoname(): η συναρτηση fifoname παιρνει σαν ορισμα εναν ακεραιο και επιστρεφει στο ονομα της ενα string το οποιο ειναι το fifo και ο ακεραιος που πηρε σαν ορισμα. Για παραδειγμα, αν καλεστει με ορισμα τον αριθμο 5 θα εποιστρεψει ενα string “fifo5”
    • chartoint(): η συναρτηση αυτη παιρνει εναν ακεραιο και επιστρεφει τον ιδιο ακεραιο με τη μορφη string. 
    • geturls(): τη λειτουργια αυτης της συναρτησης την εξηγησα μαζι με τον worker.

queueimplementation.c

Στο αρχείο αυτο υπαρχει μια κλασσικη υλοποιηση μιας ουρας (FIFO) με τη χρηστη linked lists. 

Makefile

το makefile εκτος απο το compile του κωδικα της εργασιας διαγραφει καθε φορα που καλειται τα αρχεια που εχει δημιουργησει το sniffer τις προηγουμενες φορες που ετρεξε χωρις να χρησιμοποιηθει η εντολη make sniffer.


Στην υλοποιηση μου δεν καταφερα να κανω χρηση signals για να κανω push τον worker στην ουρα με τους διαθεσιμους worker αφοτου τελειωσε. Υπαρχει στις σειρες 371-379 ενα κομματι σχολιασμένου κωδικα με το οποιο ο manager περιμενει τον worker να τελειωσει με τη χρηση της waitpid() που αμα βγει απο σχολιο το προγραμμα θα τρεξει απλα επειδη ο manager περιμενει τον πρωτο worker που γινεται pop να τελειωσει και μετα τον κανει push θα ειναι παντα αυτος ο worker που θα παιρνει τη δουλεια και επειδη για να κανει καινουργιο read απο το pipe(listener) o manager θα πρεπει να περασει το σημειο του waitpid() που σημαινει οτι ηδη θα εχει γινει push ο υπαρχον worker στην ουρα και ποτέ δεν θα χρειαστει να δημιουργθει καινουργιος worker. Τον κωδικα τον αφησα ως εχει πιστευοντας οτι δειχνει καλυτερα την λειτουγια του και τη δυνατοτητα του να διαχειριστει πολλα processes και πολλα named pipes. Το κακο ειναι οτι αφου τελειωσει ενας worker τη δουλεια του μπαινει σε stopped κατασταση και δεν ξαναδεχεται SIGCONT ποτέ. Δεν βρηκα καποιον τροπο στο χρονο που ειχα δυστυχως να βρω μια λυση. 
Επισης, δεν προλαβα να κανω το signal handling για το SIGINT για να πιανει ο manager το ctrl+C.
